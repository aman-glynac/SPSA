import logging
from typing import Dict, Any, List, Optional
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path

from config.settings import settings

logger = logging.getLogger(__name__)

@dataclass
class ClientDealContext:
    """Container for client deal context information"""
    deal_id: str
    activities: List[Dict[str, Any]]
    metadata: Dict[str, Any]
    similar_deals: List[Dict[str, Any]] = None

class LLMClientContextBuilder:
    """
    LLM-powered client context builder that generates intelligent historical context
    focused on client engagement patterns using similar deals and a dedicated LLM prompt
    """
    
    def __init__(self, llm_client=None, rag_retriever=None):
        """
        Initialize LLM client context builder
        
        Args:
            llm_client: LLM client for context generation
            rag_retriever: RAG retriever for getting similar deals
        """
        self.llm_client = llm_client
        self.rag_retriever = rag_retriever
        self.prompt_template = self._load_context_prompt()
        
        logger.info("LLM Client Context Builder initialized")
    
    def _load_context_prompt(self) -> str:
        """Load client context analysis prompt from file"""
        prompt_path = Path("prompts/client_context_analysis_prompt.txt")
        
        try:
            with open(prompt_path, 'r', encoding='utf-8') as f:
                template = f.read()
            logger.info(f"Loaded client context analysis prompt from {prompt_path}")
            return template
        except FileNotFoundError:
            logger.error(f"Client context analysis prompt file not found: {prompt_path}")
            return self._get_fallback_prompt()
        except Exception as e:
            logger.error(f"Error loading client context analysis prompt: {e}")
            return self._get_fallback_prompt()
    
    def _get_fallback_prompt(self) -> str:
        """Fallback prompt if file loading fails"""
        return """
You are a sales analytics expert. Analyze these similar deals and provide client engagement context:

{similar_deals_data}

Generate analysis in this structure:
## SIMILAR DEALS CONTEXT
## CLIENT ENGAGEMENT PATTERNS ANALYSIS
## CLIENT COMMUNICATION ANALYSIS
## CLIENT DECISION PATTERNS
## CLIENT BUYING SIGNALS ANALYSIS

Keep each section concise and focused on CLIENT behavior patterns.
"""
    
    def build_context(
        self,
        deal_id: str,
        activities: List[Dict[str, Any]],
        metadata: Dict[str, Any],
        similar_deals: List[Dict[str, Any]] = None,
        llm_client=None
    ) -> str:
        """
        Build comprehensive client context using LLM analysis
        
        Args:
            deal_id: Current deal identifier
            activities: Deal activities
            metadata: Deal metadata
            similar_deals: Similar deals from RAG retrieval
            llm_client: Optional LLM client override
            
        Returns:
            Formatted client context string generated by LLM
        """
        
        # If no similar deals provided, try to get them from RAG retriever
        if not similar_deals and self.rag_retriever:
            try:
                # Get similar deals using RAG retriever
                similar_deals = self._get_similar_deals_from_rag(deal_id, activities, metadata)
            except Exception as e:
                logger.error(f"Error getting similar deals from RAG: {e}")
                similar_deals = []
        
        if not similar_deals:
            return "## NO HISTORICAL CLIENT CONTEXT AVAILABLE\nNo similar deals found for client engagement analysis."
        
        try:
            # Use provided LLM client or fallback to instance client
            client = llm_client or self.llm_client
            if not client:
                logger.error("No LLM client available for client context generation")
                return "## ERROR\nLLM client not available for client context generation."
            
            # Format similar deals data for LLM analysis (focus on client activities)
            deals_data = self._format_deals_for_client_analysis(similar_deals[:3])  # Top 3 deals
            
            # Format prompt with deals data
            formatted_prompt = self.prompt_template.format(similar_deals_data=deals_data)
            
            # Generate context using LLM
            logger.info(f"Generating LLM client context for deal {deal_id} using {len(similar_deals)} similar deals")
            
            context = self._generate_context_with_llm(client, formatted_prompt)
            
            # Add footer
            context += "\n\n---\nUse this historical client engagement context to inform your client sentiment analysis."
            
            logger.info(f"Successfully generated LLM client context for deal {deal_id}")
            return context
            
        except Exception as e:
            logger.error(f"Error generating LLM client context for deal {deal_id}: {e}")
            return f"## ERROR\nFailed to generate historical client context: {str(e)}"
    
    def _get_similar_deals_from_rag(self, deal_id: str, activities: List[Dict[str, Any]], metadata: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Get similar deals from RAG retriever"""
        try:
            # Use RAG retriever to get similar examples
            context_string = self.rag_retriever.retrieve_relevant_examples(
                deal_id=deal_id,
                activities=activities,
                metadata=metadata
            )
            
            # For now, return empty list as we'll rely on the string context
            # In a production system, you'd want to modify RAG retriever to return structured data
            return []
            
        except Exception as e:
            logger.error(f"Error retrieving similar deals from RAG: {e}")
            return []
    
    def _format_deals_for_client_analysis(self, similar_deals: List[Dict[str, Any]]) -> str:
        """
        Format similar deals data for client-focused LLM analysis
        
        Args:
            similar_deals: List of similar deals
            
        Returns:
            Formatted string with client-focused deal data
        """
        
        if not similar_deals:
            return "No similar deals available for analysis."
        
        deals_text = []
        
        for i, deal in enumerate(similar_deals, 1):
            deal_id = deal.get('deal_id', f'Deal_{i}')
            metadata = deal.get('metadata', {})
            activities = deal.get('activities', [])
            
            # Extract key metadata
            outcome = metadata.get('outcome', 'unknown')
            deal_amount = metadata.get('deal_amount', 0)
            deal_stage = metadata.get('deal_stage', 'unknown')
            
            # Focus on client engagement metrics
            total_activities = metadata.get('total_activities', len(activities))
            response_time_avg = metadata.get('response_time_avg', 0)
            
            # Format deal header with client focus
            deal_text = [f"### Client Deal {i} (ID: {deal_id})"]
            deal_text.append(f"- Outcome: {outcome}")
            deal_text.append(f"- Amount: ${deal_amount:,.2f}" if deal_amount > 0 else "- Amount: Not specified")
            deal_text.append(f"- Stage: {deal_stage}")
            deal_text.append(f"- Total Activities: {total_activities}")
            deal_text.append(f"- Avg Response Time: {response_time_avg:.1f} hours" if response_time_avg > 0 else "- Response Time: Not available")
            
            # Add client-focused activities (filter for client activities)
            client_activities_text = self._format_client_activities_for_deal(activities)
            if client_activities_text:
                deal_text.append("- Client Activities:")
                deal_text.append(client_activities_text)
            
            deals_text.append("\n".join(deal_text))
        
        return "\n\n".join(deals_text)
    
    def _format_client_activities_for_deal(self, activities: List[Dict[str, Any]]) -> str:
        """
        Format client activities for a single deal with limits
        
        Args:
            activities: List of activities for the deal
            
        Returns:
            Formatted client activities string (max 5 activities or 1500 chars)
        """
        
        if not activities:
            return "  No client activities available"
        
        # Filter for client activities first
        client_activities = []
        for activity in activities:
            activity_type = activity.get('activity_type', 'unknown')
            direction = activity.get('direction', '').lower()
            
            # Include client-initiated activities
            if direction == 'incoming' or activity_type == 'meeting':
                client_activities.append(activity)
        
        if not client_activities:
            return "  No client-initiated activities found"
        
        activity_lines = []
        total_chars = 0
        max_chars = 1500
        max_activities = 5
        
        for i, activity in enumerate(client_activities):
            if i >= max_activities:
                break
                
            activity_type = activity.get('activity_type', 'unknown').upper()
            content = activity.get('content', '').strip()
            
            if content:
                # Truncate content if too long
                if len(content) > 200:
                    content = content[:200] + "..."
                
                activity_line = f"  - CLIENT {activity_type}: {content}"
                
                # Check character limit
                if total_chars + len(activity_line) > max_chars:
                    activity_lines.append("  - [Additional client activities truncated...]")
                    break
                
                activity_lines.append(activity_line)
                total_chars += len(activity_line)
        
        return "\n".join(activity_lines) if activity_lines else "  No meaningful client activities found"
    
    def _generate_context_with_llm(self, llm_client, prompt: str) -> str:
        """
        Generate context using LLM client
        
        Args:
            llm_client: LLM client instance
            prompt: Formatted prompt
            
        Returns:
            Generated context string
        """
        
        try:
            # Use the LLM client's provider to generate response
            response = llm_client.provider.generate_response(
                prompt=prompt,
                max_tokens=2000  # Sufficient for structured context
            )
            
            if not response or not response.strip():
                return "## ERROR\nEmpty response from LLM"
            
            return response.strip()
            
        except Exception as e:
            logger.error(f"Error calling LLM for client context generation: {e}")
            raise
    
    def get_enabled_components(self) -> List[str]:
        """Get list of enabled components (for compatibility with existing interface)"""
        return ["LLMClientContextAnalysis"]
    
    def add_component(self, component):
        """Compatibility method - not applicable for LLM approach"""
        logger.warning("add_component() not applicable for LLM-based client context builder")
    
    def remove_component(self, component_name: str):
        """Compatibility method - not applicable for LLM approach"""
        logger.warning("remove_component() not applicable for LLM-based client context builder")

# Factory function for backward compatibility
def create_client_context_builder(llm_client=None, rag_retriever=None) -> LLMClientContextBuilder:
    """Create LLM client context builder instance"""
    return LLMClientContextBuilder(llm_client=llm_client, rag_retriever=rag_retriever)

# Legacy class name alias for backward compatibility
ClientRAGContextBuilder = LLMClientContextBuilder